<section class="relative h-screen">
  <div
    id="genki-dama-container"
    class="w-full overflow-hidden pb-[40vh] sticky"
  >
    <!-- Imagen de Goku -->
    <img
      id="goku-image"
      src="/img/effects/img/goku-genki.png"
      alt="Goku levantando la Genki Dama"
      class="goku-genkidama absolute top-[28rem] left-1/2 transform -translate-x-1/2 h-auto max-h-[40vh] lg:max-h-[60vh] object-contain z-10"
    />
  </div>
</section>

<script>
  import * as THREE from "three";
  import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
  import gsap from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  gsap.registerPlugin(ScrollTrigger);

  window.addEventListener("load", init);

  function init() {
    const container = document.getElementById("genki-dama-container");

    // Crear el renderizador
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Crear la escena
    const scene = new THREE.Scene();

    // Crear la cámara
    const camera = new THREE.PerspectiveCamera(
      40,
      container.offsetWidth / container.offsetHeight,
      0.1,
      1000
    );
    camera.position.set(0, 0, 500);

    // Crear la esfera (Genki Dama)
    const geometry = new THREE.SphereGeometry(100, 30, 30);
    const material = new THREE.MeshStandardMaterial({
      emissive: new THREE.Color("rgb(0, 191, 255)"),
      emissiveIntensity: 0.8,
      transparent: true,
    });
    const genkiSphere = new THREE.Mesh(geometry, material);
    genkiSphere.position.set(0, 200, 0);
    scene.add(genkiSphere);

    // Cargar la textura del círculo
    const loader = new THREE.TextureLoader();
    const circleTexture = loader.load("/img/effects/particle.png"); // Reemplaza con la ruta de tu textura

    // Crear las partículas con la textura circular
    const particleGeometry = new THREE.BufferGeometry();
    const particleCount = 5000;
    const positions = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
      const x = (Math.random() - 0.5) * 600;
      const y = Math.random() * 600 - 400; // Inicia en un rango más bajo
      const z = (Math.random() - 0.5) * 600;
      positions.set([x, y, z], i * 3);
    }

    particleGeometry.setAttribute(
      "position",
      new THREE.BufferAttribute(positions, 3)
    );

    const particleMaterial = new THREE.PointsMaterial({
      map: circleTexture, // Usar la textura circular
      size: 10, // Tamaño de las partículas
      sizeAttenuation: true, // Para que el tamaño cambie con la distancia
      transparent: true, // Hacer las partículas transparentes
      opacity: 0.7, // Controlar la opacidad
      blending: THREE.AdditiveBlending, // Mezclar las partículas
      depthWrite: false, // Evitar escribir en el buffer de profundidad
      color: 0x48b6ff,
    });

    const particles = new THREE.Points(particleGeometry, particleMaterial);
    scene.add(particles);

    // Añadir luces
    const ambient = new THREE.AmbientLight(0xffffff, 1);
    scene.add(ambient);
    const directional = new THREE.DirectionalLight(0xffffff, 1);
    directional.position.set(1, 1, 1);
    scene.add(directional);

    // Configuración de postprocesado para Bloom
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(container.offsetWidth, container.offsetHeight),
      1.5,
      0.4,
      0.85
    );
    bloomPass.threshold = 0;
    bloomPass.strength = 2;
    bloomPass.radius = 0;

    const composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // Animar partículas
    function animateParticles() {
      const positions = particleGeometry.attributes.position.array;
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3 + 1] += 0.5; // Movimiento hacia arriba

        if (positions[i * 3 + 1] > 400) {
          positions[i * 3 + 1] = -400; // Reiniciar posición cuando supera el límite
        }
      }
      particleGeometry.attributes.position.needsUpdate = true;
    }

    function render() {
      genkiSphere.rotation.y += 0.005;
      animateParticles();
      composer.render();
      requestAnimationFrame(render);
    }

    // Ajustar tamaño en cambio de ventana
    function onResize() {
      renderer.setSize(container.offsetWidth, container.offsetHeight);
      camera.aspect = container.offsetWidth / container.offsetHeight;
      camera.updateProjectionMatrix();
      composer.setSize(container.offsetWidth, container.offsetHeight);
    }

    window.addEventListener("resize", onResize);
    onResize();
    render();

    // Animación al hacer scroll
    gsap.to(genkiSphere.scale, {
      x: 8,
      y: 8,
      z: 8,
      scrollTrigger: {
        trigger: container,
        start: "top top",
        end: "bottom top",
        scrub: true,
      },
    });
  }
</script>

<style>
  #genki-dama-container {
    perspective: 1000px;
    width: 100%;
    height: 100vh;
    overflow: hidden;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
  }

  .goku-genkidama {
    filter: drop-shadow(0 0 20px rgba(0, 191, 255, 0.8));
    animation: pulsate 1.5s infinite ease-in-out;
  }

  @keyframes pulsate {
    0% {
      filter: drop-shadow(0 0 20px rgba(0, 191, 255, 0.8));
    }
    50% {
      filter: drop-shadow(0 0 40px rgba(0, 191, 255, 1));
    }
    100% {
      filter: drop-shadow(0 0 20px rgba(0, 191, 255, 0.8));
    }
  }
</style>
